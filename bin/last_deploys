#!/usr/bin/env ruby
require 'hybrid_platforms_conductor/nodes_handler'
require 'hybrid_platforms_conductor/ssh_executor'
require 'optparse'
require 'time'
require 'terminal-table'

POSSIBLE_STRING_SORTS = [
  :admin,
  :git_repo,
  :git_branch,
  :chef_commit_id,
  :chef_commit_comment
  # :chef_options
]
POSSIBLE_SORTS = {
  datetime: proc { |hostname, deploy_info| [deploy_info.key?(:error) || !deploy_info.key?(:datetime) ? 0 : deploy_info[:datetime].strftime('%Y%m%d%H%M%S').to_i, hostname] },
  host: proc { |hostname, _deploy_info| hostname },
}.merge(Hash[POSSIBLE_STRING_SORTS.map do |property_name|
  [
    property_name,
    proc { |hostname, deploy_info| [deploy_info.key?(:error) || !deploy_info.key?(property_name) ? '' : deploy_info[property_name], hostname] }
  ]
end])

hosts = []
nodes_handler = HybridPlatformsConductor::NodesHandler.new
ssh_executor = HybridPlatformsConductor::SshExecutor.new(nodes_handler: nodes_handler)
ssh_executor.max_threads = 64
sort_by = :host
sort_desc = false
OptionParser.new do |opts|
  opts.banner = "Usage: #{$0} [options]"
  opts.separator ''
  opts.separator 'Main options:'
  opts.on('-h', '--help', 'Display help and exit') do
    puts opts
    exit 0
  end
  opts.on('-r', '--sort-by SORT', "Specify a sort. Possible values are: #{POSSIBLE_SORTS.keys.sort.join(', ')}. Each value can append _desc to specify a reverse sorting. Defaults to #{sort_by}.") do |sort_name|
    if sort_name =~ /^(.+)_desc$/
      sort_desc = true
      sort_name = $1
    end
    sort_by = sort_name.to_sym
  end
  nodes_handler.options_parse(opts)
  nodes_handler.options_parse_hosts(opts, hosts)
  ssh_executor.options_parse(opts)
end.parse!
ssh_executor.validate_params
raise "Unknown sort name: #{sort_by}. Should be one of #{POSSIBLE_SORTS.keys.join(', ')}." unless POSSIBLE_SORTS.key?(sort_by)
raise "Unknown options: #{ARGV.join(' ')}" unless ARGV.empty?

sorted_deploy_info = Hash[ssh_executor.
  run_cmd_on_hosts(
    Hash[nodes_handler.resolve_hosts(hosts).map do |hostname|
      [
        hostname,
        { bash: "cd /var/log/deployments && ls -t | head -1 | xargs sed '/===== STDOUT =====/q'" }
      ]
    end],
    log_to_stdout: false,
    concurrent: true,
    timeout: 10
  ).
  map do |hostname, (stdout, stderr)|
    # Expected format for stdout:
    # Property1: Value1
    # ...
    # PropertyN: ValueN
    # ===== STDOUT =====
    # ...
    deploy_info = { host: hostname }
    if stdout.is_a?(Symbol)
      deploy_info[:error] = "Error: #{stdout}\n#{stderr}"
    else
      stdout_lines = stdout.split("\n")
      if stdout_lines.first =~ /No such file or directory/
        deploy_info[:error] = '/var/log/deployments missing'
      else
        stdout_lines.each do |line|
          if line =~ /^([^:]+): (.+)$/
            key, value = $1, $2
            case key
            when 'date'
              # Thu Nov 23 18:43:01 UTC 2017
              deploy_info[:datetime] = Time.parse(value).strftime('%F %T')
            when 'user'
              # a_usernme
              deploy_info[:admin] = value
            when 'debug'
              # Yes
              deploy_info[:debug] = (value == 'Yes')
            when 'repo_name'
              # ansible_repo
              deploy_info[:repo_name] = value
            when 'commit_id'
              # 73c2017a2a85a5a086cd2474ce02d2755c273f3c
              deploy_info[:commit_id] = value
            when 'commit_message'
              # Added sorting capabilities
              deploy_info[:commit_message] = value
            when 'diff_files'
              # my_file.txt, other_file.txt
              deploy_info[:nbr_diff_files] = value.split(', ').size
            else
              deploy_info[key.to_sym] = value
            end
          else
            deploy_info[:unknown_lines] = [] unless deploy_info.key?(:unknown_lines)
            deploy_info[:unknown_lines] << line
          end
        end
      end
    end
    [
      hostname,
      deploy_info
    ]
  end
].sort_by(&POSSIBLE_SORTS[sort_by])
sorted_deploy_info.reverse! if sort_desc
INFO_DISPLAYED = {
  host: 'Hostname',
  datetime: 'Date',
  admin: 'Admin',
  # debug: 'Debug',
  repo_name: 'Repository',
  # commit_id: 'Commit ID',
  commit_message: 'Commit message',
  nbr_diff_files: 'Differing files',
  error: 'Error'
}
puts(Terminal::Table.new(headings: INFO_DISPLAYED.values) do |table|
  sorted_deploy_info.each do |hostname, deploy_info|
    table << INFO_DISPLAYED.keys.map { |key| deploy_info[key] }
  end
end)
