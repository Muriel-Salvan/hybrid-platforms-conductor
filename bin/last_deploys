#!/usr/bin/env ruby
require 'hybrid_platforms_conductor/nodes_handler'
require 'hybrid_platforms_conductor/ssh_executor'
require 'optparse'
require 'time'
require 'terminal-table'

POSSIBLE_STRING_SORTS = [
  :admin,
  :git_repo,
  :git_branch,
  :chef_commit_id,
  :chef_commit_comment
  # :chef_options
]
POSSIBLE_SORTS = {
  datetime: proc { |hostname, deploy_info| [deploy_info.key?(:error) || !deploy_info.key?(:datetime) ? 0 : deploy_info[:datetime].strftime('%Y%m%d%H%M%S').to_i, hostname] },
  host: proc { |hostname, _deploy_info| hostname },
}.merge(Hash[POSSIBLE_STRING_SORTS.map do |property_name|
  [
    property_name,
    proc { |hostname, deploy_info| [deploy_info.key?(:error) || !deploy_info.key?(property_name) ? '' : deploy_info[property_name], hostname] }
  ]
end])

hosts = []
nodes_handler = HybridPlatformsConductor::NodesHandler.new
ssh_executor = HybridPlatformsConductor::SshExecutor.new(nodes_handler: nodes_handler)
ssh_executor.max_threads = 64
sort_by = :host
sort_desc = false
OptionParser.new do |opts|
  opts.banner = "Usage: #{$0} [options]"
  opts.separator ''
  opts.separator 'Main options:'
  opts.on('-h', '--help', 'Display help and exit') do
    puts opts
    exit 0
  end
  opts.on('-r', '--sort-by SORT', "Specify a sort. Possible values are: #{POSSIBLE_SORTS.keys.sort.join(', ')}. Each value can append _desc to specify a reverse sorting. Defaults to #{sort_by}.") do |sort_name|
    if sort_name =~ /^(.+)_desc$/
      sort_desc = true
      sort_name = $1
    end
    sort_by = sort_name.to_sym
  end
  nodes_handler.options_parse(opts)
  nodes_handler.options_parse_hosts(opts, hosts)
  ssh_executor.options_parse(opts)
end.parse!
ssh_executor.validate_params
raise "Unknown sort name: #{sort_by}. Should be one of #{POSSIBLE_SORTS.keys.join(', ')}." unless POSSIBLE_SORTS.key?(sort_by)
raise "Unknown options: #{ARGV.join(' ')}" unless ARGV.empty?

sorted_deploy_info = Hash[ssh_executor.
  run_cmd_on_hosts(
    Hash[nodes_handler.resolve_hosts(hosts).map do |hostname|
      [
        hostname,
        { bash: "cd #{nodes_handler.platform_for(hostname).deployment_logs_dir(hostname)} && ls -t | head -1 | xargs cat | head -6" }
      ]
    end],
    log_to_stdout: false,
    concurrent: true,
    timeout: 10
  ).
  map do |hostname, stdout|
    # Expected format for stdout:
    # Date: Thu Nov 23 18:43:01 UTC 2017
    # User: a_usernme
    # GIT repository: http://172.16.0.46/git/chef-dist.git
    # Branch applied: v20171123T194235
    # Chef commit: 73c2017a2a85a5a086cd2474ce02d2755c273f3c Added sorting capabilities
    # Chef options: -o solo.rb
    deploy_info = { host: hostname }
    if stdout.is_a?(Symbol)
      deploy_info[:error] = "Error: #{stdout}"
    else
      stdout_lines = stdout.split("\n")
      if stdout_lines.first =~ /No such file or directory/
        deploy_info[:error] = '/var/log/chef-deployments missing'
      else
        stdout_lines.each do |line|
          if line =~ /^([^:]+): (.+)$/
            key, value = $1, $2
            case key
            when 'Date'
              # Thu Nov 23 18:43:01 UTC 2017
              deploy_info[:datetime] = Time.parse(value).strftime('%F %T')
            when 'User'
              # a_usernme
              deploy_info[:admin] = value
            when 'GIT repository'
              # http://172.16.0.46/git/chef-dist.git
              deploy_info[:git_repo] = value.match(/^http:\/\/(\d+\.\d+\.\d+\.\d+)\/.+$/)[1]
            when 'Branch applied'
              # v20171123T194235
              deploy_info[:git_branch] = value
            when 'Chef commit'
              # 73c2017a2a85a5a086cd2474ce02d2755c273f3c Added sorting capabilities
              deploy_info[:chef_commit_id], deploy_info[:chef_commit_comment] = value.match(/^(\w{11})\w+ (.+)$/)[1..2]
            when 'Chef options'
              # Command line options
              deploy_info[:chef_options] = value
            else
              deploy_info[key.to_sym] = value
            end
          else
            deploy_info[:unknown_lines] = [] unless deploy_info.key?(:unknown_lines)
            deploy_info[:unknown_lines] << line
          end
        end
      end
    end
    [
      hostname,
      deploy_info
    ]
  end
].sort_by(&POSSIBLE_SORTS[sort_by])
sorted_deploy_info.reverse! if sort_desc
INFO_DISPLAYED = {
  host: 'Hostname',
  datetime: 'Date',
  admin: 'Admin',
  git_repo: 'Git artefact',
  git_branch: 'Git branch',
  chef_commit_id: 'Chef commit',
  chef_commit_comment: 'Chef comment',
  # chef_options: 'Chef options',
  error: 'Error'
}
puts(Terminal::Table.new(headings: INFO_DISPLAYED.values) do |table|
  sorted_deploy_info.each do |hostname, deploy_info|
    table << INFO_DISPLAYED.keys.map { |key| deploy_info[key] }
  end
end)
